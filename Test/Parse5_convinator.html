<!DOCTYPE html>
<html>
<head>
  <title>C Parser</title>
  <script>
    // パーサーコンビネータークラス
    class Parser {
      constructor(input) {
        this.input = input;
        this.position = 0;
        this.token_end_setting =      ["\n","\r\n",")","}","]","'","'",";"," ","　","\t"]
        this.expression_end_setting = ["\n","\r\n",")","}","]","'","'",";"]
        this.line_end_setting = ["\n","\r\n"]
        this.statement_keyword_setting = ["if","for","while"]
        this.if_parse_setting = {
          "format":[
            {"type":"key","key":"if", "must_element":true},
            {
              "type":"parts",
              "format":[
                {"type":"key","key":"(", "must_element":false},
                {"type":"condition_expression", "must_element":true ,"end_element_list":[")"]},
                {"type":"key","key":")", "must_element":false}
              ],
              "must_element":true
            },
            {"type":"key","key":"{", "must_element":true},
            {"type":"statement_expression" ,"end_element_list":["}"]},
            {"type":"key","key":"}", "must_element":true}
          ]

        }
        this.for_parse_setting = {
          "format":[
            {"type":"key","key":"for", "must_element":true},
            {
              "type":"parts",
              "format":[
                {"type":"key","key":"(", "must_element":false},
                {"type":"declaration_expression", "must_element":true},
                {"type":"key","key":";", "must_element":false},
                {"type":"condition_expression", "must_element":true},
                {"type":"key","key":";", "must_element":false},
                {"type":"incrementors_expression", "must_element":true},
                {"type":"key","key":")", "must_element":false}

              ],
              "must_element":true
            },
            {"type":"key","key":"{", "must_element":true},
            {"type":"statement_expression",},
            {"type":"key","key":"}", "must_element":true}
          ]

        }
      }
      // ヘルパー関数：指定された文字列がマッチするかどうかをチェックする
      matchString(match_word) {
        if (this.input.substring(this.position, this.position + match_word.length) === match_word) {
          return true;
        }
        return false;
      }
      matchStringList(position, match_list) {
        const currentText = this.input.substring(position);
        const nextChar = this.input[position + 1];

        for (const condition of match_list) {
          if (currentText.startsWith(condition)) {
            return true;
          }
        }
        return false;
      }

      // 空白の判定を行う関数
      matchWhiteSpace(position) {
        return /\s/.test(this.input[position]);
      }
      // 文章の終了判定を行う関数
      matchExpressionEnd(position) {
        // 設定した文字現れた場合、式の終わりとみなす
        return  this.matchStringList(position,this.expression_end_setting);
      }

      // 行の終了判定を行う関数
      matchLineEnd(position) {
        // 設定した文字が現れた場合、行の終わりとみなす
        return  this.matchStringList(position,this.line_end_setting);
      }
      getUnprocessedInput(){
        return this.input.substring(this.position);
      }

      // ヘルパー関数：空白文字を無視する
      parseSkipWhitespace() {
          while (this.position < this.input.length && /\s/.test(this.input[this.position])) {
            this.position++;
          }
      }

      // トークンをパースするヘルパー関数
      parseToken(position) {
        const start_position = position;
        let end_position = position;
        while (end_position < this.input.length && !this.matchStringList(end_position,this.token_end_setting)) {
          end_position++;
        }
        const token = this.input.substring(start_position, end_position);
        return {
          token,
          endPos: end_position
        };
      }
      
      // 条件文を解析するパーサー関数
      parseCondition(end_element_list = []) {
        this.parseSkipWhitespace();
        return this.parseExpression(end_element_list);
      }

      // 文を解析するパーサー関数
      parseStatement(end_element_list = []) {
        this.parseSkipWhitespace();
        // 現在はif文かfor文のどちらかのみをサポートしています
        var statement =this.parseIfStatement();
        if (statement) {return statement;}

        statement = this.parseForStatement();
        if (statement) {return statement;}

        // 仮作成 end_element_listに到達したら終了。
        if (end_element_list !== [] && this.matchStringList(this.position,end_element_list)) {
          return {};
        }
        return this.parseExpression(end_element_list);
      }

      // 式を解析するパーサー関数
      parseExpression(end_element_list = []) {
        let tokens = [];
        let start_position = this.position;
        let end_position = this.position;
        while (end_position < this.input.length) {
          this.parseSkipWhitespace();
          if (this.matchStringList(end_position,end_element_list)){
            break;
          }
          if (this.matchExpressionEnd(end_position)) {
            break;
          }
          const token = this.parseToken(end_position);
          tokens.push(token);
          end_position = token.endPos+1;
        }
        this.position = end_position; // this.positionを更新

        return {
          type: "Expression",
          tokens,
          endPos: end_position
        };
      }
      parseWithParseSetting(setting) {
        const start_position = this.position;
        let parsedResult = {"element":[]};
        for (const element of setting.format) {
          let end_element_list = [];
          
          if ("end_element_list" in element) {
            end_element_list = element.end_element_list
          } else {
            end_element_list =[];
          }
          this.parseSkipWhitespace();
          if (element.type === "key" ) {
            if (this.matchString(element.key)){
              this.position += element.key.length;
              parsedResult["element"].push(element.key);
            }else if( element.must_element) {
              this.position = start_position;
              saveDictionaryToJSONFile("analyze_error.json",parsedResult,true);
              return null; // 要素が見つからない場合はnullを返すなど適切な処理を行う
            }else{
              this.position ++;
            }
          } else if (element.type === "condition_expression") {
            const condition = this.parseCondition(end_element_list);
            if (condition){
              parsedResult.condition = condition;
            }else if(element.must_element) {
              this.position = start_position;
              return null; // 要素が見つからない場合はnullを返すなど適切な処理を行う
            }else{
              this.position ++;
            }

          } else if (element.type === "statement_expression") {
            const statement = this.parseStatement(end_element_list);
            if (statement ){
              parsedResult.statement = statement;
            }
            else if(element.must_element) {
              this.position = start_position;
              return null; // 要素が見つからない場合はnullを返すなど適切な処理を行う
            }else{
              this.position ++;
            }

          } else if (element.type === "parts") {
            const partsResult = this.parseStatement();
            if (partsResult){
              //Object.assign(parsedResult, partsResult);
              parsedResult = mergeDictionaries(parsedResult, partsResult)
            }
            else if(element.must_element) {
              this.position = start_position;
              return null; // 要素が見つからない場合はnullを返すなど適切な処理を行う
            }else{
              this.position ++;
            }
          }
        }

        return parsedResult;
      }
      parseIfStatement() {
        var start_position = this.position;
        //this.parseSkipWhitespace();
        var result = this.parseWithParseSetting(this.if_parse_setting);

        if (!result) {
          this.position = start_position;

          return null; // パース失敗時はnullを返すなど適切な処理を行う
        }

        var condition = result.condition;
        var statement = result.statement;

        return {
          type: "IfStatement",
          condition: condition,
          statement: statement
        };
      }

      // for文を解析するパーサー関数
      parseForStatement() {
        var start_position = this.position;
        //this.parseSkipWhitespace();
        var result = this.parseWithParseSetting(this.for_parse_setting);

        if (!result) {
          this.position = start_position;
          return null; // パース失敗時はnullを返すなど適切な処理を行う
        }
        var declaration = result.declaration;
        var condition = result.condition;
        var incrementors = result.incrementors;
        var statement = result.statement;
        return {
          type: "ForStatement",
          declaration,
          condition,
          incrementors,
          statement
        };
      }
      // 複数の文を処理する関数
      parseMultipleStatements() {
        const statements = [];

        while (this.position < this.input.length) {
          const statement = this.parseStatement();

          // パース結果を文のリストに追加
          statements.push(statement);

          // 区切り文字（例: セミコロン）が現れたら次の文に進む
          if (this.matchString(";")) {
            this.position++;
            continue;
          }
          const current_char = this.input[this.position];

          // 文末文字が現れたら次の文に進む
          if (this.matchExpressionEnd(this.position)) {
            this.position++;
            continue;
          }

          // 改行文字が現れたら次の文に進む
          if (this.matchLineEnd(this.position)) {
            this.position++;
            continue;
          }
          //仮対応
          this.position++;

          // それ以外の場合は文の区切りが終わったとみなし、処理を終了
          //break;
        }

        return {
          type: "MultipleStatements",
          statements
        };
      }
      // パースを開始する関数
      parse() {
        try {
          const ast = this.parseMultipleStatements();
          return {
            success: true,
            ast: ast
          };
        } catch (error) {
          return {
            success: false,
            error: error.message
          };
        }
      }
    }
    // 解析を実行する関数
    function analyze() {
      const codeInput = document.getElementById("code-input");
      const code = codeInput.value;

      const parser = new Parser(code);
      const result = parser.parse();
      const resultOutput = document.getElementById("result-output");

      if (result.success) {
        resultOutput.innerText = JSON.stringify(result.ast, null, 2);
      } else {
        resultOutput.innerText = "Error: " + result.error;
      }
    }
    function testFunction() {


      // Test cases
      parser = new Parser(test_code);
      // Test matchString
      var test_code = "abc";
      var expected_result = true;

      parser.input = test_code;
      var result = parser.matchString("abc");
      testDisplay("result-output", "matchString_"+test_code, expected_result, result);

      // Test matchStringList
      test_code = "123";
      expected_result = true;

      parser.input = test_code;
      result = parser.matchStringList(0, ["123", "456"]);
      testDisplay("result-output", "matchStringList_"+test_code, expected_result, result);

      // Test matchWhiteSpace
      test_code = " ";
      expected_result = true;

      parser.input = test_code;
      result = parser.matchWhiteSpace(0);
      testDisplay("result-output", "matchWhiteSpace_"+test_code, expected_result, result);

      // Test matchExpressionEnd
      test_code = ";";
      expected_result = true;

      parser.input = test_code;
      result = parser.matchExpressionEnd(0);
      testDisplay("result-output", "matchExpressionEnd_"+test_code, expected_result, result);

      // Test matchLineEnd
      test_code = "\n";
      expected_result = true;

      parser.input = test_code;
      result = parser.matchLineEnd(0);
      testDisplay("result-output", "matchLineEnd_"+test_code, expected_result, result);



      test_code =  "  test";
      expected_result = "test";
      parser.input = test_code;

      parser.parseSkipWhitespace();
      result = parser.getUnprocessedInput();
      testDisplay("result-output","parseSkipWhitespace_"+test_code,expected_result,result);

      // Test parseToken
      test_code = "abc 123";
      expected_result = {
        token: "abc",
        endPos: 3
      };

      parser.input = test_code;
      result = parser.parseToken(0);
      testDisplay("result-output", "parseToken_"+test_code, JSON.stringify(expected_result), JSON.stringify(result));



      // Test parseCondition
      test_code = "x == 5;";
      expected_result = {
        type: "Expression",
        tokens: [
          {
            token: "x",
            endPos: 0
          },
          {
            token: "==",
            endPos: 2
          },
          {
            token: "5",
            endPos: 4
          }
        ],
        endPos: 6
      };

      parser.input = test_code;
      result = parser.parseCondition();
      testDisplay("result-output", "parseCondition_"+test_code, JSON.stringify(expected_result), JSON.stringify(result));

      // Test parseStatement
      test_code = "if (x == 5) { return 1; }";
      expected_result = {
        type: "IfStatement",
        condition: {
          type: "Expression",
          tokens: [
            {
              token: "x",
              endPos: 4
            },
            {
              token: "==",
              endPos: 6
            },
            {
              token: "5",
              endPos: 8
            }
          ],
          endPos: 10
        },
        statement: {
          type: "MultipleStatements",
          statements: [
            {
              type: "Expression",
              tokens: [
                {
                  token: "return",
                  endPos: 14
                },
                {
                  token: "1",
                  endPos: 20
                }
              ],
              endPos: 21
            }
          ]
        }
      };


    }
    
    function testDisplay(element_id,test_label,expected_result,result){
      var testResultsContainer = document.getElementById(element_id);
      var testResult = document.createElement('p');
      testResult.textContent = 'test_label: ' + test_label + ' | Expected: ' + expected_result + ' | Result: ' + result; 
      testResult.style.color = (result === expected_result )? 'green' : 'red'; 
      testResultsContainer.appendChild(testResult);
    }
    

    //ブラウザ種類判別関数
    function getBrowserType(){
      var browser_type ="";
      if (navigator.appName === "Microsoft Internet Explorer" ) {
        return browser_type = "Internet Explorer";
      }
      var agent = window.navigator.userAgent;
      agent = agent.toLowerCase();
      if (agent.indexOf("msie") != -1 || agent.indexOf("trident") != -1) {
        browser_type = "Internet Explorer";
      } else if (agent.indexOf("edg") != -1 || agent.indexOf("edge") != -1) {
        browser_type = "Edge";
      } else if (agent.indexOf("opr") != -1 || agent.indexOf("opera") != -1) {
        browser_type = "Opera";
      } else if (agent.indexOf("chrome") != -1) {
        browser_type = "Chrome";
      } else if (agent.indexOf("safari") != -1) {
        browser_type = "Safari";
      } else if (agent.indexOf("firefox") != -1) {
        browser_type = "FireFox";
      } else if (agent.indexOf("opr") != -1 || agent.indexOf("opera") != -1) {
        browser_type = "Opera";
      }
      return browser_type;
    }

    function saveDictionaryToJSONFile(file_name, dictionary_data,flag_browser_check) {
      var browser_IE=false; 
      if(flag_browser_check == true){
        if (getBrowserType() == "Internet Explorer"){
          browser_IE = true;
        }
      }
      var  json_result =""
      if (browser_IE == false){
        //JSON Data化
        json_result = JSON.stringify(dictionary_data);
        //var json_result = dictionary_data.map(function(data) {
        //(function(data) {
        //  return data);
        //}).join('\n');
        //File保存
        saveToFile(file_name, json_result);
      }else
        json_result = convertDictionaryToJSON(dictionary_data)
        saveToFile(file_name, json_result);
    }

    //配列の場合は追記を行い、それ以外のデータ型の場合は上書きでmergeを行う関数
    function mergeDictionaries(dictionary1, dictionary2) {
      const mergedDictionary = Object.assign({}, dictionary1);

      for (const key in dictionary2) {
        if (key in mergedDictionary) {
          if (Array.isArray(dictionary1[key]) && Array.isArray(dictionary2[key])) {
            mergedDictionary[key] = dictionary1[key].concat(dictionary2[key]);
          } else {
            mergedDictionary[key] = dictionary2[key];
          }
        } else {
          mergedDictionary[key] = dictionary2[key];
        }
      }
      return mergedDictionary;
    }

    // 辞書のJSON文字列化関数
    function convertDictionaryToJSON(obj) {
      var json_string = '{';
      var is_first_property = true;
      for (var key in obj) {
        if (obj.hasOwnProperty(key)) {
          if (!is_first_property) {
            json_string += ',';
          }
          json_string += '"' + key + '":"' + obj[key] + '"';
          is_first_property = false;
        }
      }
      json_string += '}';
      return json_string;
    }
    // ファイル保存関数
    function saveToFile(file_name, content) {
      var downloadLink = document.createElement('a');
      downloadLink.href = 'data:text/plain;charset=utf-8,' + encodeURIComponent(content);
      downloadLink.download = file_name;
      downloadLink.style.display = 'none';
      document.body.appendChild(downloadLink);
      downloadLink.click();
      document.body.removeChild(downloadLink);
    }
    // ファイル保存関数(IE専用)
    function saveToFileIE(file_name, content) {
      var file_system = new ActiveXObject("Scripting.FileSystemObject");
      var file_stream = file_system.CreateTextFile(file_name, true);
      file_stream.Write(content);
      file_stream.Close();
    }
</script>
</head>
<body>
  <h1>C Parser</h1>
  <textarea id="code-input" rows="10" cols="50">    if(a == 1){ for (b; condition; increment) {C;}}
    if(a == 1){ for (b; condition; increment) {C;}}
  </textarea><br>
  <button onclick="analyze()">Analyze</button><br>
  <button onclick="testFunction()">Test</button><br>
  <pre id="result-output"></pre>
</body>
</html>
