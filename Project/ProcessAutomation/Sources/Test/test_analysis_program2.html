<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="UTF-8" />
  <title>D3.js グラフ表示</title>
  <script src="https://d3js.org/d3.v7.min.js"></script>
  <style>
    body {
      display: flex;
      font-family: sans-serif;
      margin: 0;
      height: 100vh;
    }
    #sidebar {
      width: 300px;
      padding: 10px;
      background: #f0f0f0;
      overflow-y: auto;
      box-shadow: 2px 0 5px rgba(0,0,0,0.1);
    }
    #graph {
      flex: 1;
      overflow: hidden;
    }
    svg {
      width: 100%;
      height: 100%;
      background: #fff;
    }
    .group-rect {
      fill: none;
      stroke-width: 2;
      stroke-dasharray: 5 5;
    }
    .node circle {
      stroke: #333;
      stroke-width: 1.5px;
      fill: lightblue;
    }
    .node text {
      pointer-events: none;
      font-size: 12px;
    }
    /* リンクのデフォルトスタイル */
    .link {
      stroke: #999;
      stroke-opacity: 0.6;
    }
    /* ハイライトされたリンク用のクラス */
    .link.highlight-source {
        stroke: red !important;
    }
    .link.highlight-target {
        stroke: blue !important;
    }
    .link.highlight-bidirectional {
        stroke: purple !important; /* 新しく追加 */
    }
    .link.dimmed {
        stroke-opacity: 0.2;
    }
  </style>
</head>
<body>
  <div id="sidebar">
    <h3>操作</h3>
    <input type="file" id="fileInput" accept=".json" /><br /><br />
    <button onclick="expandNodes()">ノードを広げる</button>
    <button onclick="compressNodes()">ノードを詰める</button>

    <h4>リンククラスタ選択</h4>
    <select id="linkedGroupSelect">
      <option value="">選択してください</option>
    </select>
    <h4>ファイルグループ選択</h4>
    <select id="groupSelect">
      <option value="">選択してください</option>
    </select>
    <div id="groupInfo"></div>
    <h4>ノード情報</h4>
    <pre id="nodeInfo"></pre>
  </div>
  <div id="graph">
    <svg></svg>
  </div>

  <script>
    let simulation;
    let currentStrength = -100;
    let globalGroups = {};
    let globalNodes = [];
    let currentLinks = [];
    let selectedFileGroupId = null;
    let selectedLinkedClusterId = null;
    let linkedClusters = [];
    let d3NodeSelection;
    let d3LinkSelection;
    let clickedNodeIdForHighlight = null;

    const svg = d3.select("svg");
    const width = window.innerWidth - 300;
    const height = window.innerHeight;
    const g = svg.append("g");

    // 矢印マーカー定義
    svg.append("defs").append("marker")
      .attr("id", "arrowhead")
      .attr("viewBox", "-0 -5 10 10")
      .attr("refX", 20)
      .attr("refY", 0)
      .attr("orient", "auto")
      .attr("markerWidth", 6)
      .attr("markerHeight", 6)
      .attr("xoverflow", "visible")
      .append("svg:path")
      .attr("d", "M0,-5L10,0L0,5")
      .attr("fill", "#999")
      .style("stroke", "none");

    // ハイライト用のマーカーも定義
    svg.append("defs").append("marker")
      .attr("id", "arrowhead-red")
      .attr("viewBox", "-0 -5 10 10")
      .attr("refX", 20)
      .attr("refY", 0)
      .attr("orient", "auto")
      .attr("markerWidth", 6)
      .attr("markerHeight", 6)
      .attr("xoverflow", "visible")
      .append("svg:path")
      .attr("d", "M0,-5L10,0L0,5")
      .attr("fill", "red")
      .style("stroke", "none");

    svg.append("defs").append("marker")
      .attr("id", "arrowhead-blue")
      .attr("viewBox", "-0 -5 10 10")
      .attr("refX", 20)
      .attr("refY", 0)
      .attr("orient", "auto")
      .attr("markerWidth", 6)
      .attr("markerHeight", 6)
      .attr("xoverflow", "visible")
      .append("svg:path")
      .attr("d", "M0,-5L10,0L0,5")
      .attr("fill", "blue")
      .style("stroke", "none");
    
    // 紫色用のマーカーを追加
    svg.append("defs").append("marker")
      .attr("id", "arrowhead-purple")
      .attr("viewBox", "-0 -5 10 10")
      .attr("refX", 20)
      .attr("refY", 0)
      .attr("orient", "auto")
      .attr("markerWidth", 6)
      .attr("markerHeight", 6)
      .attr("xoverflow", "visible")
      .append("svg:path")
      .attr("d", "M0,-5L10,0L0,5")
      .attr("fill", "purple")
      .style("stroke", "none");

    function expandNodes() {
      currentStrength -= 100;
      updateForceStrength();
    }

    function compressNodes() {
      currentStrength += 100;
      updateForceStrength();
    }

    function updateForceStrength() {
      if (simulation) {
        simulation
          .force("charge", d3.forceManyBody().strength(currentStrength))
          .alpha(1)
          .restart();
      }
    }

    const zoom = d3.zoom()
      .scaleExtent([0.1, 10])
      .on("zoom", (event) => {
        g.attr("transform", event.transform);
      });

    svg.call(zoom);

    document.getElementById("fileInput").addEventListener("change", function () {
      const file = this.files[0];
      if (file) {
        const reader = new FileReader();
        reader.onload = function (e) {
          try {
            const json = JSON.parse(e.target.result);
            renderGraph(json);
          } catch (err) {
            alert("JSONファイルの読み込み中にエラーが発生しました: " + err.message);
            console.error(err);
          }
        };
        reader.readAsText(file);
      }
    });

    function renderGraph(data) {
      try {
        g.selectAll("*").remove();

        const elements = data.elements;
        let groups = data.groups || {};

        const nodes = Object.entries(elements).map(([id, el]) => ({
          id,
          ...el,
          label: el.label || id
        }));
        const nodeIds = new Set(nodes.map(n => n.id));
        let links = [];
        const missingNodes = [];

        nodes.forEach(node => {
          if (node.links) {
            node.links.forEach(link => {
              let targetId = null;
              let color = null;

              if (typeof link === 'string') {
                targetId = link;
              } else if (typeof link === 'object' && link.name) {
                targetId = link.name;
                color = link.color;
              }

              if (targetId) {
                if (!nodeIds.has(targetId)) {
                  nodeIds.add(targetId);
                  missingNodes.push({
                    id: targetId,
                    label: targetId + " (存在しません)",
                    missing: true
                  });
                }
                links.push({ source: node.id, target: targetId, color });
              }
            });
          }
        });

        // 相互リンクの検出
        const linkMap = new Map();
        links.forEach(link => {
            const key = `${link.source}:${link.target}`;
            linkMap.set(key, link);
        });

        links.forEach(link => {
            const reverseKey = `${link.target}:${link.source}`;
            if (linkMap.has(reverseKey)) {
                link.isBidirectional = true;
                linkMap.get(reverseKey).isBidirectional = true; // 逆方向のリンクもマーク
            } else {
                link.isBidirectional = false;
            }
        });


        nodes.push(...missingNodes);
        globalNodes = nodes;
        currentLinks = links; // リンク情報を保存

        const groupedNodeIds = new Set();
        Object.values(groups).forEach(group => {
          group.elements.forEach(id => groupedNodeIds.add(id));
        });

        const ungroupedNodes = nodes.filter(n => !groupedNodeIds.has(n.id));
        if (ungroupedNodes.length > 0) {
          const newGroupId = "ungrouped";
          let suffix = 1;
          while(groups[newGroupId + (suffix > 1 ? suffix : "")]) {
            suffix++;
          }
          const finalGroupId = newGroupId + (suffix > 1 ? suffix : "");
          groups[finalGroupId] = {
            label: "未分類ノード",
            elements: ungroupedNodes.map(n => n.id)
          };
        }

        globalGroups = groups;

        simulation = d3.forceSimulation(nodes)
          .force("link", d3.forceLink(links).id(d => d.id).distance(120))
          .force("charge", d3.forceManyBody().strength(currentStrength))
          .force("center", d3.forceCenter(width / 2, height / 2))
          .on("tick", ticked);

        d3LinkSelection = g.selectAll(".link")
          .data(links)
          .enter().append("line")
          .attr("class", "link")
          .attr("stroke", d => d.color || "#999")
          .attr("marker-end", "url(#arrowhead)");

        d3NodeSelection = g.selectAll(".node")
          .data(nodes)
          .enter().append("g")
          .attr("class", "node")
          .call(d3.drag()
            .on("start", dragstarted)
            .on("drag", dragged)
            .on("end", dragended));

        d3NodeSelection.append("circle").attr("r", 5);
        d3NodeSelection.append("text")
          .attr("x", 12)
          .attr("dy", 4)
          .text(d => d.label);

        d3NodeSelection.on("click", function(event, d) {
          event.stopPropagation();
          document.getElementById("nodeInfo").textContent = JSON.stringify(d, null, 2);
          
          if (clickedNodeIdForHighlight === d.id) {
              clickedNodeIdForHighlight = null;
              resetLinkColors();
          } else {
              clickedNodeIdForHighlight = d.id;
              highlightLinks(d.id);
          }
        });
        
        svg.on("click", (event) => {
            if (event.target.tagName === "svg" || (event.target.tagName === "rect" && d3.select(event.target).classed("group-rect"))) {
                if (clickedNodeIdForHighlight !== null) {
                    clickedNodeIdForHighlight = null;
                    resetLinkColors();
                }
            }
        });

        function ticked() {
          d3LinkSelection
            .attr("x1", d => d.source.x)
            .attr("y1", d => d.source.y)
            .attr("x2", d => d.target.x)
            .attr("y2", d => d.target.y);

          d3NodeSelection.attr("transform", d => `translate(${d.x},${d.y})`);

          let visibleNodeIdsForGroups = new Set(globalNodes.map(n => n.id));
          if (selectedLinkedClusterId) {
              const clusterIdx = parseInt(selectedLinkedClusterId.split(":")[1]);
              visibleNodeIdsForGroups = new Set(linkedClusters[clusterIdx]);
          }
          renderGroups(globalGroups, globalNodes, visibleNodeIdsForGroups);
        }

        function dragstarted(event, d) {
          if (!event.active) simulation.alphaTarget(0.3).restart();
          d.fx = d.x;
          d.fy = d.y;
        }

        function dragged(event, d) {
          d.fx = event.x;
          d.fy = event.y;
        }

        function dragended(event, d) {
          if (!event.active) simulation.alphaTarget(0);
          d.fx = null;
          d.fy = null;
        }

        const groupSelect = document.getElementById("groupSelect");
        groupSelect.innerHTML = '<option value="">選択してください</option>';
        Object.entries(groups).forEach(([key, val]) => {
          const opt = document.createElement("option");
          opt.value = key;
          opt.textContent = val.label || key;
          groupSelect.appendChild(opt);
        });

        groupSelect.onchange = (e) => {
          selectedFileGroupId = e.target.value;
          document.getElementById("groupInfo").textContent = selectedFileGroupId && globalGroups[selectedFileGroupId]
            ? JSON.stringify(globalGroups[selectedFileGroupId], null, 2)
            : "";
          
          d3NodeSelection.select("text").attr("fill", "black");
          if (selectedFileGroupId && globalGroups[selectedFileGroupId]) {
            const groupNodeIds = new Set(globalGroups[selectedFileGroupId].elements);
            d3NodeSelection.filter(d => groupNodeIds.has(d.id))
                           .select("text")
                           .attr("fill", "red");
          }
          
          let visibleNodeIdsForGroups = new Set(globalNodes.map(n => n.id));
          if (selectedLinkedClusterId) {
              const clusterIdx = parseInt(selectedLinkedClusterId.split(":")[1]);
              visibleNodeIdsForGroups = new Set(linkedClusters[clusterIdx]);
          }
          renderGroups(globalGroups, globalNodes, visibleNodeIdsForGroups);
        };

        const linkedGroupSelect = document.getElementById("linkedGroupSelect");
        linkedGroupSelect.innerHTML = '<option value="">選択してください</option>';
      
        linkedClusters = getLinkedClusters(currentLinks);
        linkedClusters.forEach((cluster, idx) => {
          const opt = document.createElement("option");
          opt.value = "linked:" + idx;
          opt.textContent = `LinkedGroup-${idx + 1} (${cluster.length}ノード)`;
          linkedGroupSelect.appendChild(opt);
        });
      
        linkedGroupSelect.addEventListener("change", (e) => {
          selectedLinkedClusterId = e.target.value;
          
          if (!selectedLinkedClusterId) {
            d3NodeSelection.style("display", null);
            d3LinkSelection.style("display", null);
            document.getElementById("nodeInfo").textContent = "";
            fitGraphToView(globalNodes);
            renderGroups(globalGroups, globalNodes, new Set(globalNodes.map(n => n.id)));
            clickedNodeIdForHighlight = null;
            resetLinkColors();
            return;
          }

          const clusterIdx = parseInt(selectedLinkedClusterId.split(":")[1]);
          const visibleIds = new Set(linkedClusters[clusterIdx]);

          d3NodeSelection.style("display", d => visibleIds.has(d.id) ? null : "none");
          d3LinkSelection.style("display", d => (visibleIds.has(d.source.id) && visibleIds.has(d.target.id)) ? null : "none");

          const filteredNodes = globalNodes.filter(n => visibleIds.has(n.id));
          fitGraphToView(filteredNodes);
          
          renderGroups(globalGroups, globalNodes, visibleIds);
          clickedNodeIdForHighlight = null;
          resetLinkColors();
        });

        simulation.on("end.initialFit", () => {
            fitGraphToView(globalNodes);
            simulation.on("end.initialFit", null);
        });
      
        function getLinkedClusters(links) {
          const parent = {};
          const find = x => parent[x] === x ? x : (parent[x] = find(parent[x]));
          const union = (a, b) => {
            const pa = find(a), pb = find(b);
            if (pa !== pb) parent[pa] = pb;
          };

          globalNodes.forEach(n => { parent[n.id] = n.id; });
          links.forEach(link => union(link.source.id, link.target.id));

          const clusters = {};
          globalNodes.forEach(n => {
            const root = find(n.id);
            if (!clusters[root]) clusters[root] = [];
            clusters[root].push(n.id);
          });

          return Object.values(clusters).filter(arr => arr.length > 1);
        }
  
      } catch (err) {
        alert("グラフ描画中にエラーが発生しました: " + err.message);
        console.error(err);
      }
    }  
    
    function renderGroups(groups, nodes, filterNodeIds = null) {
      g.selectAll(".group-rect").remove();
      g.selectAll(".group-label").remove();
    
      Object.entries(groups).forEach(([key, group]) => {
        const groupNodeData = nodes.filter(n => group.elements.includes(n.id) && filterNodeIds.has(n.id));
        
        if (groupNodeData.length === 0) return;

        const xCoords = groupNodeData.map(n => n.x);
        const yCoords = groupNodeData.map(n => n.y);
        
        if (xCoords.some(isNaN) || yCoords.some(isNaN)) return;

        const padding = 20;
        const minX = Math.min(...xCoords) - padding;
        const minY = Math.min(...yCoords) - padding;
        const maxX = Math.max(...xCoords) + padding;
        const maxY = Math.max(...yCoords) + padding;

        const rectWidth = maxX - minX;
        const rectHeight = maxY - minY;
    
        g.append("rect")
          .attr("class", "group-rect")
          .attr("x", minX)
          .attr("y", minY)
          .attr("width", rectWidth)
          .attr("height", rectHeight)
          .attr("stroke", key === selectedFileGroupId ? "red" : "blue");
        g.append("text")
          .attr("class", "group-label")
          .attr("x", minX + 5)
          .attr("y", minY + 15)
          .attr("fill", key === selectedFileGroupId ? "red" : "black")
          .attr("font-size", "12px")
          .text(group.label || key);
      });
    }

    function fitGraphToView(nodesToFit) {
        if (!nodesToFit || nodesToFit.length === 0) {
            console.warn("ズーム対象ノードがありません。");
            return;
        }

        if (simulation.alpha() > simulation.alphaMin()) {
            simulation.on("end.fit", () => {
                performFit(nodesToFit);
                simulation.on("end.fit", null);
            });
            if (simulation.alpha() < 0.05) {
                simulation.alpha(0.05).restart();
            }
        } else {
            performFit(nodesToFit);
        }
    }

    function performFit(nodesToFit) {
        const validNodes = nodesToFit.filter(n => typeof n.x === 'number' && typeof n.y === 'number');
        if (validNodes.length === 0) {
            console.warn("有効なノード位置情報がないためフィットできません。");
            return;
        }

        const xCoords = validNodes.map(n => n.x);
        const yCoords = validNodes.map(n => n.y);

        const minX = Math.min(...xCoords);
        const maxX = Math.max(...xCoords);
        const minY = Math.min(...yCoords);
        const maxY = Math.max(...yCoords);

        const graphWidth = maxX - minX;
        const graphHeight = maxY - minY;

        const padding = 50; 
        const viewBoxWidth = graphWidth + padding * 2;
        const viewBoxHeight = graphHeight + padding * 2;

        const scaleX = width / viewBoxWidth;
        const scaleY = height / viewBoxHeight;
        const scale = Math.min(scaleX, scaleY, 1.5);

        const centerX = (minX + maxX) / 2;
        const centerY = (minY + maxY) / 2;

        const translateX = (width / 2) - centerX * scale;
        const translateY = (height / 2) - centerY * scale;
        
        svg.transition()
            .duration(750)
            .call(zoom.transform, d3.zoomIdentity.translate(translateX, translateY).scale(scale));
    }

    function highlightLinks(clickedNodeId) {
      d3LinkSelection
        .attr("stroke", d => {
            if (d.isBidirectional && (d.source.id === clickedNodeId || d.target.id === clickedNodeId)) {
                return "purple";
            } else if (d.source.id === clickedNodeId) {
                return "red";
            } else if (d.target.id === clickedNodeId) {
                return "blue";
            } else {
                return d.color || "#999";
            }
        })
        .attr("marker-end", d => {
            if (d.isBidirectional && (d.source.id === clickedNodeId || d.target.id === clickedNodeId)) {
                return "url(#arrowhead-purple)";
            } else if (d.source.id === clickedNodeId) {
                return "url(#arrowhead-red)";
            } else if (d.target.id === clickedNodeId) {
                return "url(#arrowhead-blue)";
            } else {
                return "url(#arrowhead)";
            }
        })
        .classed("dimmed", d => {
            // クリックされたノードと全く関係ないリンクを薄くする
            return d.source.id !== clickedNodeId && d.target.id !== clickedNodeId;
        })
        .classed("highlight-source", d => d.source.id === clickedNodeId && !d.isBidirectional)
        .classed("highlight-target", d => d.target.id === clickedNodeId && !d.isBidirectional)
        .classed("highlight-bidirectional", d => d.isBidirectional && (d.source.id === clickedNodeId || d.target.id === clickedNodeId));
    }

    function resetLinkColors() {
      d3LinkSelection
        .attr("stroke", d => d.color || "#999")
        .attr("marker-end", "url(#arrowhead)")
        .classed("dimmed", false)
        .classed("highlight-source", false)
        .classed("highlight-target", false)
        .classed("highlight-bidirectional", false); // 追加
    }
  </script>
</body>
</html>